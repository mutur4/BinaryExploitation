> # Binning

- When `free()` is called a chunk is released an stored in a free-list bin.
- These are linked lists that stored free chunks and prevent recurrent calls to the kernel.
- Therefore Less Kernel Interraction == High Performance.
- When memory is requested again instead of malloc interacting with the allocators, 
it just checks in these free lists for a chunk of that size.


> ### Fast Bins

- These are free list bins that store or hold freed chunks called fast chunks. These are chunks of
between `0x20 - 0x80` in size. (size requested + chunk medata)
- These chunks are inserted and removed from the head of the fast bin linked list.
- There are 10 such fast bins and each of the fastbins idx are separated by size of 0x10.
- They are of singly-linked lists by nature therefore they have only one pointer that is the fd pointer that points to the next chunk on the fast bin.
- There is a global variable called the `global_max_fast` and this holds the size of the largest allowable
fastbin for free to create.The max value is 0x80 in 64-bit systems =)
- When freed fastbin chunks are not merged with the top chunk since they either end up in the fastbins or the [tcache](#tcache)
depending in the version of libc that is available.

```
#include <stdio.h>
#include <stdlib.h>

int main(){
	char *a = malloc(0x20);
	free(a); // Adding a fastbin chunk into the fastbin =)
}
```

> ## Bins

- This is an array in the main arena that contains the small bins, large bins and the unsorted bins.
- bin[0] this is not used and contains nothing
- bin[1]: This is where the unsorted bin is located
- bin[2] - bin[63]: This is the location of the small bin.
- bin[64] - bin[126]: This is the location of the large bin.

> ### Small Bins

- There are a total of 62-small bins in the bin array.
- Small bins are faster than large-bins and slower compared to fastbins.
- Each bin maintains a doubly-linked lists where insertion happens at the 
HEAD of the bin are removal from the TAIL of the bin. Therefore First-In-First-Out.
- The method of insertion and deletion is similar to that of the unsorted bin.
- Each bin stores chunks of the same size like fastbins. The 62-bins have size ranges of 16, 24, ...etc
- The small bin miminum size is `0x90` and maximum `0x500` in 64_bit systems.

> ### Large Bins
- There are 63-large bins where each bin maintains a doubly linked list.
- A bin has chunks of diffrent sizes that are sorted in decreasing order from 
the largest to the samled.
- Insertions are removals happen at any position of the bin list.
- The first 32 bins contain chunks that are 64-bytes apart.
	1st bin : 0x400 - 0x420
	2nd bin: 0x440 - 0x480

> ### Unsorted Bins

- The unsorted bin is located at index 0 of the bin therefore there is onyl one unsorted bin.
- The unsorted bin is used to temporaliry hold a chunk that is freed and that does not end up in the tcache or the
fastbin.
- When an allocation is made and the chunk request is less that what this bin holds, this requested size is
sliced from the unsorted bin.
- When an allocation is made and a chunk is present in the unsorted bin, if the size is greater 
that what is in this bin, it is then added to its corresponding bin, large or small bin.
- Addition happens at the head of the unsorted bin and deletion happens and the tail of the unsorted bin.
- Therefore this First-In-First-Out algorithm.
- If there are 2 chunks of diffrent sizes in the unsorted bin and `malloc()` requested
for a smaller chunk, the largest chunk is popped off and the smaller bin is 
chopped off. 

> ## Top Chunk

- This is sometimes also called the heap wilderness.
- When memory is allocated, malloc allocats more memory than what was requested and threfore this ends
up in top chunk.
- This is called the last resort, this is because the last place malloc will look when there is not 
free chunk in the free lists during allocation.
- Therefore the requested memory will be chopped off from the top chunk :smile:
 
> ## Tcache

- This is a bin that was introduced in libc version 2.26.
- There are total of 64 tcache bins per thread.
- A computer system usually has one or more threads running at the same time.
- Multiple threads allows a process to execute multiple concurrent operation for example A high volume web-server might
have multiple incoming requests and the webserver might service each incoming request
on its own thread.
- Therefore each thread in a given process shares the same address space and therefore 
each thread can see the same code and data in memory.
- Each thread therefore gets its own registers and stack to store temp local varable
but resources like global variable and the heap are shared between all of the threads.
- Coordination access to global resources like the heap and doing it wrong can lead
to a problem called a "race conditions" that are exploitable by hackers.
- The heap solves the problem of thread by using per_thread arena where eacn thread
gets its own arena until it hits the threshold.
- The tcache per-thread arena is designed to reduce the cost of the lock because the 
lock instructions are expensive and end up taking a significant portion of the 
executtion time.
- per-thread cachine speeds up alloactions by having per-thread bins of small chunk ready.
- Therefore when a thread requests a chunk, if the thread has a chunk available on it
tcache it can service the allocation without ever needing to wait on the heap lokc.
- Each thread has 64 singly linked tcache bins and each bin contains a max of 7-same size chunks ranging from 24 - 1032 bytes on 64-bit systems and 
12 to 5616 on 32 bit systems

#### The difference between calloc() and malloc() in allocation from Tcache and Fastbins =)

> `__libc_calloc()` allocates memory using `int_malloc` that does not allocate memory
>from the tcache.
>
> `__libc_malloc()` attempts to allocate from the tcache first and only calls `_int_malloc` if if fails to get an allocation.
>This therefore is used to establish the difference between `calloc` and `malloc` since calloc() does not attempt to allocate
>from the tcache.


