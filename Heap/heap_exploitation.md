# Heap Exploitation

- Heap exploitation these are the programming bugs that make the heap vulnerable to certain attacks.
- The following are the diffrent not limited to heap attacks methods used.

```
+--------------------+----------------------------+-----------------------+
|   Bug Used         |  Bin Attack                |   House               |
+--------------------+----------------------------+-----------------------+
|                    |  Fast Bin Attack           |   House of Spirit     |
|   Double Free      |  tcache attack             |   House of Lore       |
|   Heap Overflow    |  Unsorted Bin Attck        |   House of Force      |
|   Use After Free   |  Small / Large Bin Attck   |   House of Einherjar  |
|                    |  Unsafe Unlink             |   House of Orange     |
+--------------------+----------------------------+-----------------------+
						  |   House of Husk =)    |
--------------------------------------------------+-----------------------+
```

Bug Used | Bin Attack | House 
------------------------------
Double Free | FastBin attack | House of Spirit
Heap Overflow | Tchache attack | House of Lore
Use After Free | Unsorted Bin Attack | House of Force
 | Small/Large Bin Attack | House of Einherjar
 | Unsafe Unlink | House of Orange
 | | House of Husk

- The bugs these are certain programmer mistakes that can lead to other attacks.
- These are the first things to check in a heap challenge =)
- The bin attacks are the diffrent attacks the affect the free list bins altogether =)
- The houses are essentially different types of Heap Attacks that we can do in diffrent situations
that do different things.
- They are built from the bin attacks and they can get alot more complicated that some of 
the typical bin attacks.

# Double Free

- The Double Free bug this is a type of bug where the attacker can free a chunk of memory more than once.
- Therefore this means that the free bin will have more than one chunk freed. The attacker can therefore 
use this bug to edit a freed chunk and therefore leading to memory corruption errors.
- These can lead to other serious bugs including leaking addressess and other bin attacks. 

- The following are the 2 main reasons why Double Free can be successfull (fastchunks):
	1. The (prev_in_use) bit of the next_chunk will not be cleared after the 
	heap block of the fastbin is released.
	2. When the fastbin executes free, it only verifies the block directly pointed
	to by main_arena and that is the block at the head of the linked list pointer.
	- For all the chunks behind the linked list, no verification is performed.

- Therefore the FastBinDoubleFree this is a type of attack that is also still currently 
executable in the recent version of libc =).
- This type of attacks mainly affect FastBin chunks.

# Heap Overflow

- This is where the attacker is able to write passed the buffer that they are allocated.
- The attacker can therefore write into the next chunk in memory and therefore edit the chunks 
metadata and therefore this can lead to heap memory corruption errors.
- Heap overflows can be offbyonebyte that is mainly cause by the wrong use of loops or overflows
that can be lead by certain functions including but not limited to scanf() and gets().

# Use After Free

- When a chunk of memory is requested by malloc() a pointer is returned.
- The UAF bug this is a  type of bug where the user can use a pointer that points to a chunk on 
the heap that was released or freed.
- Therefore this type of bug can lead to memory corruption errors including leaking addresses, 
overwriting or messing up with the chunks fwd and bk pointers altogether.
- This type of bug is due to the programmers error and therefore to prevent the bug the pointer 
where released should be clear out or nulled.
- The type of bug affected the lastest version of libc =).

```
#include <stdio.h>
#include <stdlib.h>

void main(){
	unsinged long int *a, *b;
	a = (unsigned long int *) malloc(0x8);
	a = 0x7fff;
	free(a);
	printf("0x%lx\n", a); // UAF vulnerability
}
```


## Bin Attacks

- These are the different types of attacks that are used to attack the diffrent heap bins.

# FastBin Attack

- There are 10 fasbins that act as linked lists. These bins are separated by 
a size of 0x10 bytes and they stored values from 0x20 - 0x80 bytes.
- The objective of the fastbin attack is to allocate a chunk to a memory
region of choosing and this is done after we edit a pointer to point to 
out fake chunk. The value of the (fd) pointer.
- These are certain checks that malloc does to determine if the chunk is valid or
not but this can be bypassed easily.

# GLIBC Tcache Attack

- The tcache this is a bin that stores recently freed chunks (max 7 per idx by default)
- The tcache consists of a linked list where one chunk points to the next chunk.
- tl;dr The tcache fd pointer points to the data region of the next chunk in memory.
- The attack consists of using a bug to overwrite a pointer in the linked list to
an address we want to allocate, then allocating it when it thats chunks turn to be 
allocated.
- Since tcache was introduced in glibc version 2.26, therefore this type of
attack wont work in earlier version of glibc.
- This attack is also called tcache poisoning. The attack is more strict on later version of glibc =)

# Unsorted Bin Attack 

- The Unsorted Bin is a doubly linked lists.
- When a chunk is removed from the unsorted bin, the chunks (bk) pointer + 0x10 is updated with 
a new value.
- This is because we all know that a chunk is removed from the tail in the unsorted bin therefore 
the (fd) pointer of the (prev) chunk in the bin is updated in this way. This is because the (fd)
pointer will no longer point to this chunk because we are removing it from the bin =)

- We do not control whatever is written but we can control where we write using a bug like a heap 
overflow or a UAF bug.
- The value that is written is a large value altogether.
- The versions of libc where this attack is possible is libc starting from versino 2.28 and less
the other later versions of glibc have some form of protection and by these mitigations can be 
byapssed. =)


# LargeBin Attack

- A large bin this is a bin that is used to hold large chunks this is after they 
are temprorarily held by the unsorted bin.
- A large bin attack this is an attack that is similar to the unsorted bin attack
in that they both enable the attacker write into a pointer.
- We can control where the pointer is written to but cannot control whatever we write 
in the pointer.
- The following is a snippet of the source code that is used to remove a chunk from the 
unsorted bin to the large bin.

```
while ((victim = unsorted_chunks(av) -> bk != unsorted_chunks(av))){
}
```
- The above code is a loop that is used to check is there are chunks 
available in the unsorted bin and if the condition is True the following
snippets of code are run.

```
if (in_smallbin_range(nb) && bck == unsorted_chunks (av) && victim == av -> last_remainder && (unsigned long) (size) > (unsigned long) (nb + MINSIZ))

```
- The above snippet of code is used to check is used to check the last chunk
in the unsorted bin. The size of the retreived chunk is suitable for the requested
chunk, the retreived chunk is the last remainder and the requested byte is less than 
MIN_LARGE_SIZE, the chunk will be divided into the requested chunk. The chunk of the requested
size will be returned to the user and the remaining chunk will be inserted into 
the unsorted bin.

``` if (size == nb) ```

- The code above is used to check if the size of the chunk in the unsorted bin is
the same as the requested size and therefore if they are the same block is returned directly to 
the user.

``` if (in_smallbin_range(size)) ```

- The above is used to check if the size of the heap block in the unsorted bin is 
within the range of the small bin, get the index of the corresponding small bin
and insert the block into the small bin.

- If all of the above conditions are not met, therefore it is considerred that the 
chunk in the unsorted bin belongs to the large bin size range and we now enter 
the step of inserting a chunk into the large bin.


```
if (fwd != bck){
	~~~~~~~~~~~
}else{
	victim -> fd_nextsize = victim -> bk_nextsize = victim;
}
```

- This is used to first determine if the large bin is empty, if it is empty, 
directly set the fd_nextsize and bk_nextsize of the chunk to itself.
- If it is not empty we do proceed to the next step.

```
if ((unsigned long) (size) < (unsigned long ) chunksize_nomask (bck -> bk)){
	fwd = bck;
	bck = bck -> bk;
	victim -> fd_nextsize = fwd -> fd;
	victim -> bk_nextsize = fwd -> fd -> bk_nextsize;
	fwd -> fd > bk_nextsize = victim -> bk_nextsize -> fd_nextsize = victim;
}
```

- The above code means if the heap block is less than the size of the last heap 
block in the large bin, we insert the freed heap block as the last block into 
the large bin.( This is because the large bins are sorted from the largests to the smallest)

- Otherwise we traverse from the head of the linked list until we find the first
linked list whose size is greater than or equal to the chunk to be inserted.
- After finding that chunk we judge whethere the size of the linked list is equal to 
the size of the chunk to be inserted.
- If they are equal, we directly insert this chunk into the current linked list.
- The second position, if its not equal, means that the chunk to be inserted is larger than 
the size of the head node of the current linked list.
- Then we will insert the chunk to be inserted as the head node of the current linked list and 
insert it after the bin index that matches the size.

- The following is the line of code that is used to overwrte our pointer with a value that 
we cannot control.


```
else{
	victim -> fd_nextsize = fwd;
	victim -> bk_nextsize = fwd -> bk_nextsize;
	fwd -> bk_nextsize = victim;
	victim -> bk_nextsize -> fd_nextsize = victim; // This is used to edit the pointer that we choose
}

victim -> bk = bck;
victim -> fd = fwd;
fwd -> bk = victim; // This is used to overwrite the fwd->bk pointer
bck -> fd = victim;
```
victim :  This is the chunk that is currently being added to the linked list
fwd: This is the chunk that is currently in the linked list.

## Heap Feng Shui (Heap Gromming)

- The heap has alot of predictable behaviour.
- Heap gromming is therefore a technique where we can manipulate the heap in certain ways so that it 
performs certain actions.
- For performance malloc will reuse recentely freed chunks if they fit the size.
- An example:
	1. Allocating 3 fastbin chunks and freeing them in order, then allocating 3 chunks of the same size malloc will return
	the chunks in reverse order therefore we are able to predict future chunks
	that will be allocated =)

## Unlink Exploitation

- We say that a chunk is unlinked either from their small and large bins during heap consolidation.
- The simplest implementation of unlink without an protections is as follows.
- The old glibc implements the unlink function as a macr0

```
#define unlink(P, BK, FD){
	BK = P -> bk;
	FD = p -> fd;
	FD -> bk = BK;
	BK -> fd = FD
}
```
- (P) this is the pointer to the chunk to remove.BK and FD they are 2 temp variables
that store the diffrent neighbours to "P".
- If we are able to control the chunk pointed to by "P" we are able to control
the values of the FD and BK.
- unlink() will do the following in detailed.	
	BK = *(P + 12)
	FD = *(P + 8)
	*(FD + 12) = BK
	*(BK + 8) = FD

- This is because the chunk is removed in the middle of the doubly linked list the fd
and the bk pointers of the prev and next chunks should therefore be updated.
- If we therefore control the (P) chunk atleast in the old glibc we have a 
write anywhere privillege and we can also control whatever we write =) and therefore 
where we write is *(FD + 12) and *(BK + 8) and whatever we write is BK and FD.
(in 32-bit systems ) =(
- Newer version of glibc hardens this technique by adding sanity checks for chunk
headers in the unlink() function.


## Houses =)

# House of Spirit

- The House Of Spirit attack is therefore as follows.
- We create two fake chunks by writing two integers to a region of memory that will 
represent the sizes of the fake chunks.
- Then we get a pointer to point to the first chunk and free it.
- Then we get malloc to return a pointer to that memory region and so it allows us to 
get `malloc()` to return a pointer to a region of memory that we can write two integers too.
- Therefore the House Of Spirit attack allows us to get get malloc to return a fake chunk 
to a region of memory that we control like the stack or the bss segment.
- There are diffrent requirements for this type of attack to work and they are as follows:
	1. The (int)s size should be the chunks size plus the chunks metadata.
	2. The (data) section should be exactly the chunk metadata size - 10h in 64-bit systems therefore
	the size of the next chunk should start at (chunk size - 10h)

# House of Lore

- The House of lore is an attack that uses the process of reallocating chunks
corresponding to small bins and placing chunks into small bins.
- The allocator checks if the size requested for memory allocation is on the small
bin range.This code is found in the unsorted bin while loop.
	- If the requested size is in the small bin range, the index corresponding to 
	the requested size is found.
	- Compare the value of bin[index] with the value stored in bin[index] -> bk.
	- Save the value stored in bin[index] -> bk to the "victim" and check that 
	this value is zero.
- If the value stored in "victim" is not 0, the value stored in victim -> bk is stored in bck.
	- Then check if the values of bck -> fd and "victim" and different.
	- If they are not the same, the allocator print an error message  and 
	the process is terminated.
	- If they are the same set PREV_INUSE at victim->size and the value of bck
	is stored in bin -> bk and the value of bin is stored in bck -> fd
- Check if the arena is the main arena:
	- If not the main arena, set NON_MAIN_ARENA (0x4) flag in the victim -> size.
	- The allocator the calls chunk2mem() to store the address to return (victim + 2 * SIZE_SZ) in *p and return p


- The House of Lore can therefore be used to create a FakeChunk on the stack or bss and
can be impelemented if it can overwrite the bk value of the free chunk in the small bin =).
- The steps include the following:
	1. Write a fake free chunk on the stack and allocate memory for asmall bin.
	2. Free this memory to make it free chunks.
	3. When requesting for a new memory allocation, free chunk are placed in
	BINS[]
	4. Overwrite the Fake chunks pointer with the free chunks bk
	5. When you malloc() to allocate a chunk stored in the small bin, the 
	start address of the FakeChunk is placed in Bins[]
	6. When a request is made to malloc() the same amount of memory allocation
	returns a pointer to the area of the fake chunk.
	7. The pointer returned is stack memory.

- The structure of the fake chunks matter in the House Of Lore
	1. The chunks must have the strcuture of a free chunk and requires 
	2 fake chunks
	2. You nned to store the pointer to the first fake chunk in bk of the free chunk
	in the heap and the pointer to bins[idx] in the fd of the first fake chunk
	3. Store a pointer to the first fake chunk in "bk" of the free chunk on the heap.
	4. Store a pointer to bins[idx] in "fd" of the first Fake chunk.
	5. The pointer to the second fake chunk is store in "bk" of the first free chunk.
- This structure bypasses the check that the double-linked list of chunks placed in 
the small bin is broken ("bck ->fd != victim")
	- For example in the following structure the value of "victim" is 0xdeafbeef and the value of bck->fd is 0xdeadveef therefore it bypassed the 
	verification check (condition).

# House of Force

- This is similar to the house of lore and this attack focuses on returning a pointer from malloc().
- This is a type of attack that exploits the top chunk that is also called the wilderness.
-  It borders the end of the heap and it is not present in any bin. If uses the same
format of the chunk structure.
- This attack is assumes that a bug e.g HeapOverflow will edit the top chunks headers.
- The size of the topchunk is modified to a very large value e.g (-1) therefore this 
is used to ensure that all the initial requests will be serviced using the top chunk 
instead of mmap.
- On a 64-bit systems the value evaluates to 0xffffffffffffffff and therefore a chunk with
this size can cover the entire memory space of the programme.
- Assuming that the attacker wishes malloc() to return address p. 
- Therefore any malloc call with the size of (&top_chunk - p) will be serviced using the
top chunk.
- Note the (p) can therefore be after or before the top_chunk. If its before the top 
chunk, the result will be a large +ve value because the size will be unsigned.
- Therefore an integer overflow will occurs and malloc() will succesfully service this request
using the top chunk.
- The top chunk will point to (p) and nay future requests will return p.
- The victim can therefore be any address on the stack, bss, data segment etc.


```
#include <stdio.h>
#include <string.h>
#include <unistd.h>

int main(){
	unsigned long *a = malloc(0x10);
	printf("The Size of the TopChunk: 0x%lx\n", a[3]);
	a[3] = (unsigned long ) 0xffffffffffffffff;
	return 0;
}
```
- If a heap based vulnerability wants to be exploited via the House Of Force the following 
conditions are required.
	1. The size field of the top chunk can be controlled by an overflow.
	2. Freely control the size of the heap allocation size.

- A chunk is allocated from the top chunk if all the free bins cannot meet the demand.
- What happens when the size value of the heap block allocated by the top chunk is 
an arbitraty value controlled by the user? The answer is that the top chunk can be made 
to point at any location that we expect, that is equivalent to an arbitrary address write.
- However in glibc the size requested by the user and the existing size of the top
chunk are verified.

- Malloc() allocates memory using the top chunk in the following ways.
	1. Stores the value of the main_arena -> top in "victim" and the size of 
	the top chunk in "size"
	2. Malloc() uses the space in the top chunk if the value of "size" is greater than or 
	equal to the Newly Requested Memory Size (nb) + Minimum Chunk Size (MINSIZE)
	3. Store the value stored in "size" minus the size of the newly requested memory (nb)
	in the "remainder_size" and the value stored in "victim" plus the size of the newly
	requested memory (nb) in "remainder".
	4. "remainder" is stored in main_arena -> top.
	5. Using the set_head() function it saves the newly request memory size (nb) in "victim->size" and 
	stores the value of "remainder_size" in "remainder->size".
	6. Malloc() calls chunk2mem() with victim as the argument a function that returns the address (p+2*SIZE_SZ).

```
victim  = av->top;
size = chunksize(victim)

if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE)){
	remainder_size = size - nb;
	remainder = chunk_at_offset(victim, nb); // This is where the exploitation happens. This is what gives us the memory that can be used to allocation
	av->top = remainder;
	set_head(victim, nb | PREV_INUSE | av != &main_arena ? NON_MAIN_ARENA : 0);
	set_head(remainder, remainder_size | PREV_INUSE);
	check_malloced_chunk(av, victim, nb);
	void *p = chunk2mem(victim);
	alloc_pereturb(p, bytes);
	return p; // This is used to returned the malloced() pointer =)
}
```
- If the size of the top chunk is tampered to a larger value therefore this 
verification can be bypassed.

`(unsigned long) (size) >= (unsigned long ) (nb + MINSIZE)`

- The general approach is the change the value of the size of the top chunk to -1.
- The size will be converted to an unsigned number during the comparison so therefore 
-1 means that the largest number is unsigned long  therefore this will bypass the 
verification altogether.

```
remainder = chunk_at_offset(victim, nb);
av->top = remainder;

```

- The top pointer will be updated and the next heap block will be allocated to 
this location.
- As long as the user controls this pointer, it is equivalent to writing any value at 
any address. (write-anything-anywhere)


# House of Einherjar

- The main objective of this type of attack is to get malloc() to return a chunk that 
is outside of the heap segment.
- Therefore this is a techqniue that exploits the process of _int_free() registering
chunks with top chunks.
- The free() function checks if the pointer is a chunk to be included in the fastbin.
	- If the chunk is not in the fastbin, check if the chunk was obtained by 
	mmap()
	- If the chunk is not the chunk obtained by mmap(), make sure the arena is locked()
		- If the arena is not locked, lock it.
	- _int_free() checks whethere the passed pointer and the arena top have the same value.
	- It then checks whether the next chunk is beyond the bounds of the arena 
	and whether the next chunk is not actually used.
	- Then check is the chunk size is smaller than the minimum size and larger that 
	the value of the arena system_mem
		- This verifies that the size of the next chunk is normal.
- _int_free() checks to see if the chunks size has the PREV_IN_USE flag set.
	- If the bit of the flag is set, the "size" of the chunk plus the "prev_size"
	is stored in the size variable.
	- Then a call to chunk_at_offset() to return a pointer minus prev_size from that
	chunks pointer that is stored in the variable (p)
		- The call to unlink() to remove the chunk from the empty list.
- _int_free() checks if the next chunk is a top chunk
	- If the next chunk is a top chunk, the size of the next chunk is added to the 
	size variable.
	- Set the PREV_IN_USE flag to the value of the variable.
	- Pass the variable size and the variable (p) to set_head() to 
	set the chunks header.
	- Store the variable (p) on top of the arena.


- This House attack can be implemented if you can write fake chunks in memory
and change the headers of in_use chunks.
	1. Write a fake chunk on the stack and allocate 2 memory of size not 
	corresponding to fastbins.
	2. Change the values of the header of the chunk that was allocated last.
		- Remove the PREV_INUSE flag from the value of size.
		- Save the chunks header address minus the address of the chunk
		to "PREV_SIZE"
		
	3. Fake chunks should have the following values:
		- Store the same size in "prev_size" as the last chunk allocated.
		- Save the subtracted address of the chunk header from the last 
		allocated chunk to "soze" and save the address of the fake chunk
		to fd and bk.
	4. When the last chunk is released, the fake chunks address is stored at
	arena -> top.
	5. When requesting memory allocation return a pointer to the area of the fake chunk.

Example:
- Allocate some mem of size (0x70, 0xf0) and write a fake chunk on the stack.
	1. Store 0x100 in the fake chunks prev_size and save it into "size" after
	subtracting the fake chunks address from the chunks address.
	2. Remove the PREV_INUSE flag from the value of the chunks size to
	free and save the value of the chunks size to prev_size
	3. When free that chunk the fake chunk becomes a TopChunk.
	4. When requesting for the next memory allocation, you are allocated 
	a realm of the fake chunk =)
 
